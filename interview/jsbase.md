# 01 Js基础


原型链

函数具有prototype 属性对象，其constructor 指向函数本身；new 一个函数的实例，实例的 __proto__ 属性指向函数的 prototype；而函数的 __proto__ 属性指向上一层的 Object，如此就形成了从下到上的原型链

访问实例属性时，读取顺序为：实例自身的属性 > 构造函数的prototype 属性 > Object 的属性

组合继承：子函数内执行父函数call方法改变this；new 父实例赋值给子函数prototype，并把constructor 改回子函数

寄生组合继承：与组合继承差不多，只是通过Object.create(父函数)把prototype 赋值给子函数的 prototype；这样就优化少了一次去 new 父实例

深拷贝：https://www.w3cschool.cn/article/8b3a1e469cd340.html


作用域

Js是词法作用域，在函数定义时就确定了变量作用域，决定了调用函数时的作用域。

当执行函数的时候，会创建一个上下文压入栈中，函数内定义的变量、函数存在于当前上下文中；函数执行完后将上下文弹出栈，然后垃圾回收（还被引用的不被回收）。

https://github.com/mqyqingfeng/Blog

闭包

闭包之所以能够形成，是因为函数作用域，被内部函数引用进作用域链，再把函数返回出来在外部执行时，通过作用域链访问内部的变量。
问题：因为闭包的变量一直被引用，无法被回收占用着内存，操作不当容易内存泄漏

应用场景

单例模式：利用作用域确保单一的实例，不存在时创建，存在时直接返回已有的

模块：利于作用域拥有私有变量，外部无法直接读取、变更

柯里化curry：主要在于参数复用，先传部分参数执行函数，获得复用参数的新函数

组合函数compose：接收多个处理函数返回一个新函数，新函数接收传参执行后，依次执行处理函数，并将上一个函数的返回值传递给下一个函数作为参数

垃圾回收

浏览器的Js有自动的垃圾回收机制，会定时周期性的去找出不再使用的变量，然后释放其内存

在执行上下文栈结束后，给栈/堆变量标记清除，然后回收器就会将其销毁；
不定期的去查找引用，将不再被引用的变量销毁；
或通过引用计数，每引用一次+1，移除-1，当计数为0时则销毁


防抖

利用闭包+定时器，控制延时执行函数，在延时期间再次触发后将前一个定时器清除，重新定时执行
控制连续的执行操作，只在最后一次执行，比较重视最后的效果

节流

利用闭包+时间戳计算，对比现在和上一次的执行时间，是否超过间隔时间
控制指定时间内只执行一次，比较重视减少频率和及时执行
