# 03 设计模式

https://github.com/ascoders/weekly
https://juejin.cn/post/6844904032826294286
https://www.cnblogs.com/TomXu/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/


创建型

工厂方法模式  其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。逻辑隔离、解耦合同时允许定义不太类型

function createProduct(type) {
	let types = {…}
	return types[type]
}

抽象工厂模式  它能创建一系列相关的对象， 而无需指定其具体类。抽象多种类型，根据组合创建对象

function createProduct(type, style) {
	let types = {…}
	let styles = {…}
	return Object.assgin({}, types[type], styles[style])
}

生成器模式  将一个复杂对象的构建流程与它的表示分离，使得同样的构建过程可以创建不同的表示。

function director(builder) {
	builder.buildA()
	builder.buildB()
	return builder.done()
}
class ProductBuilder {
	buildA() {}
	done{}
}
let product = director(new ProductBuilder())

原型模式  用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

单例模式  让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。


结构型

适配器模式  能使接口不兼容的对象转换成可以使用的对象。比如兼容与平台无法直接使用的API

桥接模式  将抽象部分与它的实现部分分离，使它们可以独立地变化

组合模式  一种统一管理树形结构的抽象方式；比如组件

装饰模式  通过将对象放入包含行为的特殊封装函数中来为原对象绑定新的行为。

外观模式  能为复杂系统、 程序库或框架提供一个简单 （但有限） 的接口

享元模式  是一种共享对象的设计模式，会将不同对象的相同数据进行缓存以节省内存

代理模式  让你能提供真实对象的替代品给客户端使用


行为型

职责链模式  请求的发送者和接收者之间，可以按顺序执行多个处理逻辑 ，减少耦合关系；比如中间件

命令模式   将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求进行执行操作。

迭代器模式  让你能在不暴露复杂数据结构内部细节的情况下，遍历其中所有的元素。

中介者模式  为减少对象相互之间的耦合关系，限制对象之间的直接交互， 而只通过中介者交互

备忘录模式  在操作变更时，在内部保存之前的状态、快照到历史栈中，以撤回到之前的状态。

观察者模式  定义对象间一对多的订阅发布关系，当一个对象的状态发生改变时，所有订阅的对象都得到通知并处理对应的操作。

订阅发布模式  自定义的事件订阅发布，多对多的关系

状态模式  在对象的内部状态变化时改变其行为，不通过 if else 判断，而是通过分别状态对应的处理

策略模式  能让你定义一系列算法， 通过不同的需求、特征，以使算法的对象能够相互替换（比如导航路线）

模板方法模式  它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤

访问者模式 允许你在不修改已有代码的情况下向已有类层次结构中增加新的行为


SOLID六大设计原则

单一职责原则 （Single Responsibility Principle）
一个类或函数对象只处理单一的一个逻辑、功能，保持独立，以降低耦合复杂度

开闭原则 （Open Closed Principle）
对扩展开放，对修改封闭；在扩展上新代码，而非修改已有代码

里氏替换原则 （Liskov Substitution Principle）
子类继承父类的东西，但子类可以对其重写

迪米特法则 （Law of Demeter）
一个对象对外应该暴露尽量少的参数或属性，不要将一些不必要的暴露出来

接口隔离原则 （Interface Segregation Principle）
保持接口的单一独立，类似单一职责原则，这里更关注接口

依赖倒置原则 （Dependence Inversion Principle）
依赖比自己跟抽象的对象，而不应该比自己具体的对象


https://juejin.cn/post/6847902225717854215#heading-8

